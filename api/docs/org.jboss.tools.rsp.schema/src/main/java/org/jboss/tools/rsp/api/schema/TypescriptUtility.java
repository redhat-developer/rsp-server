/*******************************************************************************
 * Copyright (c) 2018 Red Hat, Inc. Distributed under license by Red Hat, Inc.
 * All rights reserved. This program is made available under the terms of the
 * Eclipse Public License v2.0 which accompanies this distribution, and is
 * available at http://www.eclipse.org/legal/epl-v20.html
 * 
 * Contributors: Red Hat, Inc.
 ******************************************************************************/
package org.jboss.tools.rsp.api.schema;

import java.io.File;
import java.io.IOException;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

import cz.habarta.typescript.generator.Input;
import cz.habarta.typescript.generator.JsonLibrary;
import cz.habarta.typescript.generator.Output;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.TypeScriptOutputKind;

public class TypescriptUtility {

	private static final String PROTOCOL_TYPE_FILE = "protocol.unified.d.ts";
	private static final String TS_TYPE_FILE_SUFFIX = ".d.ts";

	private String baseDir;

	public TypescriptUtility(String baseDir) {
		this.baseDir = baseDir;
	}

	public void writeTypescriptSchemas(Class<?>[] daoClasses) throws IOException {
		if( daoClasses == null || daoClasses.length == 0 ) {
			// TODO error somehow? 
			return;
		}
		
		URLClassLoader cl = (URLClassLoader) daoClasses[0].getClassLoader();
		
		File daoFolder = getDaoTypescriptFolder().toFile();
		if (!daoFolder.exists()) {
			daoFolder.mkdirs();
		}

		final Settings settings = new Settings();
		settings.outputKind = TypeScriptOutputKind.module;
		settings.jsonLibrary = JsonLibrary.jackson2;
		String[] clazNames = new String[daoClasses.length];
		for (int i = 0; i < daoClasses.length; i++) {
			writeTypescriptType(daoClasses[i], settings);
			clazNames[i] = daoClasses[i].getName();
		}		

		File output = getDaoTypescriptFolder().resolve(PROTOCOL_TYPE_FILE).toFile();
		new TypeScriptGenerator(settings).generateTypeScript(
				Input.fromClassNamesAndJaxrsApplication(
						Arrays.asList(clazNames), null, null, false, null, cl, true), 
				Output.to(output));
	}

	private void writeTypescriptType(Class<?> clazz, final Settings settings) throws IOException {
		Path p = getDaoTypescriptFile(clazz.getSimpleName());
		File output = p.toFile();
		List<String> classes = Arrays.asList(clazz.getName());

		new TypeScriptGenerator(settings).generateTypeScript(
				Input.fromClassNamesAndJaxrsApplication(
						classes, null, null, false, null, (URLClassLoader) clazz.getClassLoader(), true),
				Output.to(output));
		
		// It loads the files with stupid autogenerated garbage
		String contents = safeReadFile(p);
		String trimmed = trimFirstLines(contents);
		Files.write(p, trimmed.getBytes());
	}

	private static String trimFirstLines(String contents) {
		int beginning = -1;
		for( int i = 0; i < 3; i++ ) {
			beginning = contents.indexOf('\n', beginning + 1);
			if( beginning == -1 ) {
				return "";
			}
		}
		return contents.substring(beginning).trim();
	}

	public Path getDaoTypescriptFile(String simpleClassName) {
		Path folder = getDaoTypescriptFolder();
		Path out = folder.resolve(simpleClassName + TS_TYPE_FILE_SUFFIX);
		return out;
	}

	public Path getDaoTypescriptFolder() {
		return new File(baseDir).toPath()
				.resolve("src").resolve("main").resolve("resources").resolve("schema").resolve("typescript");
	}

	public void cleanFolder() {
		Path folder = getDaoTypescriptFolder();
		File[] ts = folder.toFile().listFiles();
		for( int i = 0; i < ts.length; i++ ) {
			ts[i].delete();
		}
	}

	private static String safeReadFile(Path p) {
		if(p.toFile().exists()) {
			try {
				String content = new String(Files.readAllBytes(p));
				return content;
			} catch(IOException ioe) {
				// return ""
			}
		}
		return "";
	}
}
